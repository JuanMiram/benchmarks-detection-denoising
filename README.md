# A benchmark for time-frequency denoising/ detecting methods

## Summary

- [A benchmark for time-frequency denoising/ detecting methods](#a-benchmark-for-time-frequency-denoising-detecting-methods)
  - [Summary](#summary)
  - [What is this benchmark?](#what-is-this-benchmark)
  - [How to use this benchmark?](#how-to-use-this-benchmark)
    - [Cloning this repository](#cloning-this-repository)
    - [Using a template file for your method](#using-a-template-file-for-your-method)
    - [Adding your method's dependencies with ```poetry```](#adding-your-methods-dependencies-with-poetry)
    - [Checking everything is in order with ```pytest```](#checking-everything-is-in-order-with-pytest)
    - [Branching the repository](#branching-the-repository)
    - [Running this benchmark locally](#running-this-benchmark-locally)
  - [Standard benchmark for denoising methods](#standard-benchmark-for-denoising-methods)
  - [Standard benchmark for detection methods](#standard-benchmark-for-detection-methods)

## What is this benchmark?

A benchmark is a comparison between different methods when running an standardized test. The goal of this benchmark is to compare different methods for denoising / detecting a signal based on different characterizations of the time-frequency representation of the signal. In particular, our goal is to evaluate the performance of techniques based on the zeros of the spectrogram and to contrast them with more traditional methods, like those based on the ridges of that time-frequency distribution.

Nevertheless, the methods to compare, the tests, and the performance evaluation functions were conceived as different modules, so that one can assess new methods without modifying the tests or the signals. On the one hand, the tests and the performance evaluation functions are encapsulated in the class `Benchmark`. On the other hand, the signals used in this benchmark are generated by the methods in the class `SignalBank`. The only restriction this poses is that the methods should satisfy some requirements regarding the *shape of their input an output parameters*.

## How to use this benchmark?

You can use this benchmark to test a new method against others. There are at least two ways of doing this. You can either make a new branch of this repository and push a new method to test, or you can clone this repository and benchmark your own method locally, i.e. in your computer. In the first case, a workflow using GitHub actions will automatically detect your new method and run the standard benchmark tests. In the second case you can run the benchmark with all the modifications you need.

The [*notebooks*](./notebooks/) folder contains a number of minimal working examples to understand how this benchmark works and how you could use it for your project. In particular, [*demo_benchmark.ipynb*](./notebooks/demo_benchmark.ipynb) gives two minimal working examples to introduce the basic functionality of the `Benchmark` class, and the notebook [*demo_signal_bank.ipynb*](./notebooks/demo_signal_bank.ipynb) showcases the signals produced by the `SignalBank` class.

The instructions below will help you to add a new method run the benchmark afterwards.

### Cloning this repository

First you should have a local copy of this repository to add and modify files. For this, open a terminal in the directory you prefer and use:

```bash
git clone https://github.com/jmiramont/benchmark-test.git
```

A new method can be tested against others simply by adding a file that contains it into the folder [src/methods](./src/methods). To do this, you method must first have the following signature:

```python
    def a_new_method(signals, params):
        ...
```

Methods should receive an `M`x`N` numpy array of signals, where `M` is the number of signals, and `N` is the number of their time samples. Additionally, they should receive a second parameter `params` to allow testing different combinations of input parameters. The shape of the output depends on the task (*denoising* or *detection*). The output of your method must be of a certain shape and type, regarding the task your method is devoted to:

- For Denoising: The output must be a numpy array and have the same shape as the input (an array of shape `M`x`N`).
- For Detection: The output must be an array whose first dimension is equal to `M`.

Now you have to add a file with your method in the folder [src/methods](./src/methods/). Let's see how to do this in the following section.

### Using a template file for your method

The name of the file with your method must start with *method_* and have certain content to help the benchmark to automatically discover new added methods:

1. The file should encapsulate your method in a new class that inherits from a template called `NewMethod`.
2. The file must include a the definition of a function `instantiate_method()` that instantiates an object of the class that represent your method.

This is much easier than it sounds :). To make it simpler, [a file called *method_new_basic_template.py* is provided](./new_method_example/method_new_basic_template.py) which you can use as a template. You just have to fill in the parts that implement your method.

Let's take a look at the different parts of the template file  *method_new_basic_template.py*. In the first section of the template file you can either import a function with your method, or implement everything in this file:

```python
from methods.MethodTemplate import MethodTemplate
# You must import the MethodTemplate abstract class.

"""
|
| Import here all the modules you need.
| Remark: Make sure that neither of those modules starts with "method_".
|
"""

""" 
|
| Put here all the functions that your method uses.
| Remark: Make sure that this file starts with "method_".
|
| def a_function_of_my_method(signal,params):
|   ...
|
"""
```

In the next part of the file, your method is encapsulated in a new class called `NewMethod` (you can change this name if you prefer to). The only requisite for the class that represents your method is that it inherits from the [abstract class](https://docs.python.org/3/library/abc.html) `MethodTemplate`. Abstract classes are not implemented, but they serve the purpose of establishing a template for new classes by forcing the implementation of certain *abstract* methods. This simply means that you will have to implement a class method called -unsurprisingly- `method()`:

```python

""" Create here a new class that will encapsulate your method.
This class should inherit the abstract class MethodTemplate.
By doing this, you must then implement the class method: 

def method(self, signal, params)

which should receive the signals and any parameters
that you desire to pass to your method.You can use this file as an example.
"""

class NewMethod(MethodTemplate):

    def method(self, signals, params = None): # Implement this method.
        ...

    # def get_parameters(self):            # Use it to parametrize your method.
    #     return [None,]      

```

This function could act as a wrapper of your method, or you might implement everything in the same function, this is up to you :).

If you want to test your method using different sets of parameters, you can also implement the function `get_parameters()` to return a list with the desired input parameters (you can find an example of this [here](./new_method_example/method_new_with_parameters.py)).

In the last part of the file you can define a task and a name for your method:

```python
""" Here you can define the task your new method is devoted to 
(denoising or detection). You can also choose a method name.
"""
method_task = 'denoising' # 'denoising' or 'detection'
method_name = 'a_new_method'

def instantiate_method():
    return NewMethod(method_task,method_name)
```

This last function, `instantiate_method()`, creates and initialize an object of the class that encapsulates all your method. This will be used later to automatically recognize valid methods to benchmark. It's not necessary to modify this function since it uses the constructor that it's already implemented in the abstract class.

*Remark: Please do not modify the abstract class `MethodTemplate` or the function `instantiate_method()` at the end of the template file.*

Finally, **you have to move the file** with all the modifications to the folder [/src/methods](./src/methods). Changing the name of the file is possible, but keep in mind that **the file's name must start with "*method_*" to be recognizable**.

### Adding your method's dependencies with ```poetry```

Your method might need particular modules as dependencies that are not currently listed in the dependencies of the default benchmark. You can add them using [```poetry```](https://python-poetry.org/docs/), a tool for dependency management and packaging in python. First install ```poetry``` following the steps described [here](https://python-poetry.org/docs/#installation). Once you're done with this, open a terminal in the directory where you clone the benchmark (or use the console in your preferred IDE) and make ```poetry``` create a virtual environment and install all the current dependencies of the benchmark:

```bash
poetry install 
```

After this, add all your dependencies by modifying the ```.toml``` file in the folder, under the ```[tool.poetry.dependencies]``` section. For example:

```bash
[tool.poetry.dependencies]
python = ">=3.8,<3.11"
numpy = "^1.22.0"
matplotlib = "^3.5.1"
pandas = "^1.3.5"
```

A more convenient and interactive way to do this interactively is by using ```poetry```, for example:

```bash
poetry add numpy
```

and following the instructions prompted in the console.

*Remark: Notice that the use of ```poetry``` for adding the dependencies of your packet is key for running the benchmark using [GitHub Actions](./.github/workflows), please consider this while adding your method.*

### Checking everything is in order with ```pytest```

Once your dependencies are ready, you should check that everything is in order using the ```pytest``` testing suit. To do this, simply run the following in a console located in your local version of the repository:

```bash
poetry run pytest
```

This will check a series of important points for running the benchmark online, mainly:

1. Your method class inherits the ```MethodTemplate``` abstract class.
2. The inputs and outputs of your method follows the required format according to the designated task.

Once the tests are passed, you can now either branch the repository or run the benchmark locally.

### Branching the repository

First, create a new branch using:

```bash
git branch new_branch
```

After this, you can upload your new branch with:

```bash
git push origin new_branch
```

This should create a new branch called ```new_branch```, that stems from the default repository. Once this is done, the benchmark is run remotely using GitHub Actions.

*Remark: Notice that ```pytest``` is also run again in this workflow. Therefore, keep in mind that if your method didn't pass the tests locally, it won't pass them at this stage either.*

### Running this benchmark locally

If you prefer to run the benchmark locally, you can use:

```bash
poetry run run_this_benchmark.py
```

## Standard benchmark for denoising methods

## Standard benchmark for detection methods
