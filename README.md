# A benchmark for time-frequency denoising/ detecting methods

## What is this benchmark?

A benchmark is a comparison between different methods when running an standardized test. The goal of this benchmark is to compare different methods for denoising / detecting a signal based on different characterizations of the time-frequency representation of the signal. In particular, our goal is to evaluate the performance of techniques based on the zeros of the spectrogram and to contrast them with more traditional methods, like those based on the ridges of that time-frequency distribution.

Nevertheless, the methods to compare, the tests, and the performance evaluation functions were conceived as different modules, so that one can assess new methods without modifying the tests or the signals. On the one hand, the tests and the performance evaluation functions are encapsulated in the class `Benchmark`. On the other hand, the signals used in this benchmark are generated by the methods in the class `SignalBank`. The only restriction this poses is that the methods should satisfy some requirements regarding the *shape of their input an output parameters*.

You can use this benchmark to test a new method against others. There are at least to ways of doing this. You can either make a new branch of this repository and push a new method to test, or you can clone this repository and benchmark your own method locally, i.e. in your computer.

The `notebook` folder contains a number of minimal working examples to understand how this benchmark works and how could you use it for your project. In particular, *demo_benchmark.ipynb* introduces de idea of the benchmark and give two minimal working examples of how to use it. Additionally, the notebook *demo_signal_bank.ipynb* shows the signals produced by the `SignalBank` class.

## How to use this benchmark?

There two ways of using this benchmark to test new methods:

1. Create a new branch of this repository
2. Running the benchmark locally

### 1. Benchmark new methods by branching this repository

The benchmark runs every time a new branch of the default repository is created. This way, a new method can be tested against others simply by adding it to the folder of methods functions. To do this, you method must first met the following signature:

```python
    def a_new_method(signals, params):
        ...
```

Methods should receive an `M`x`N` numpy array of signals, where `M` is the number of signals, and `N` is the number of their time samples. Additionally, they should receive a second parameter `params` to allow testing different combinations of input parameters. The shape of the output depends on the task (denoising or detecting). The output of your method must be of a certain shape and type, regarding the task your method is devoted to:

* For Denoising: The output must be a numpy array and have the same shape as the input (an array of shape `M`x`N`).
* For Detection: The output must be an array of `M` boolean values.

Following this, you have to add a file with your method in the folder `src/methods`. To make this easier, there is a file called `method_new.py` you can use as a template. Let us see how to use this file.

In the first part of the file you can either import a function with your method, or implement everything in this file:

```python
from methods.MethodTemplate import MethodTemplate
# You must import the MethodTemplate abstract class.

"""
|
| Import here all the modules you need.
| Remark: Make sure that neither of those modules starts with "method_".
|
"""

""" 
|
| Put here all the functions that your method uses.
| Remark: Make sure that this file starts with "method_".
|
| def a_function_of_my_method(signal,params):
|   ...
|
"""
```

Then, your method is encapsulated in a new class called `NewMethod`. This class must inherit from the abstract class `MethodTemplate`. Abstract classes are not implemented but they serve the purpose of establishing a template for new classes by forcing the implementation of abstract methods. This simply means that you will have to implement a class method called -unsurprisingly- `method`:

```python

""" Create here a new class that will encapsulate your method.
This class should inherit the abstract class MethodTemplate.
By doing this, you must then implement the class method: 

def method(self, signal, params)

which should receive the signals and any parameters
that you desire to pass to your method.You can use this file as an example.
"""

class NewMethod(MethodTemplate):

    def method(self, signals, params = None): # Implement this method.
        ...

    # def get_parameters(self):            # Use it to parametrize your method.
    #     return [None,]      

```

If you want to test your method using different sets of parameters, you can make the function `get_parameters()` to return a list with the desired input parameters.

In the last part of the file you can define a task and a name for your method:

```python
""" Here you can define the task your new method is devoted to 
(detecting or denoising). You can also choose a method name.
"""
method_task = 'denoising' # 'denoising' or 'detection'
method_name = 'a_new_method'

def instantiate_method():
    return NewMethod(method_task,method_name)
```

As you can see, the last function instantiates an object that encapsulates all your method. This will be used later to automatically benchmark your new method.

### 2. Cloning and running this benchmark locally
